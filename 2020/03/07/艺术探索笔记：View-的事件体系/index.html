<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />






















<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=6.0.0" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=6.0.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=6.0.0">


  <link rel="mask-icon" href="/images/logo.svg?v=6.0.0" color="#222">





  <meta name="keywords" content="Hexo, NexT" />




  


  <link rel="alternate" href="/atom.xml" title="lemay" type="application/atom+xml" />






<meta name="description" content="View 的事件体系View 是一种界面层的控件的一种抽象，它代表着一个控件。ViewGroup 继承自 View，内部包含了许多个控件，即一组 View。这意味着 View 本身可以是单个控件也可以是多个控件组成的一组控件，即 View 树的结构。所以 View 的事件体系即控件的事件体系。 View的基础知识View的位置参数View 的位置主要由它的四个顶点来决定，分别对应于 View 的四">
<meta property="og:type" content="article">
<meta property="og:title" content="艺术探索笔记：View 的事件体系">
<meta property="og:url" content="http:&#x2F;&#x2F;blog.lemayli.com&#x2F;2020&#x2F;03&#x2F;07&#x2F;%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%EF%BC%9AView-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB&#x2F;index.html">
<meta property="og:site_name" content="lemay">
<meta property="og:description" content="View 的事件体系View 是一种界面层的控件的一种抽象，它代表着一个控件。ViewGroup 继承自 View，内部包含了许多个控件，即一组 View。这意味着 View 本身可以是单个控件也可以是多个控件组成的一组控件，即 View 树的结构。所以 View 的事件体系即控件的事件体系。 View的基础知识View的位置参数View 的位置主要由它的四个顶点来决定，分别对应于 View 的四">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTIwNDY3MTg3NTQsNjA4ODM4NDMyJmZtPTE1JmdwPTAuanBnJTIwJTIyVmlldyUyMEhpZXJhcmNoeSUyMg?x-oss-process=image&#x2F;format,png">
<meta property="og:updated_time" content="2020-03-07T08:00:39.036Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https:&#x2F;&#x2F;imgconvert.csdnimg.cn&#x2F;aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTIwNDY3MTg3NTQsNjA4ODM4NDMyJmZtPTE1JmdwPTAuanBnJTIwJTIyVmlldyUyMEhpZXJhcmNoeSUyMg?x-oss-process=image&#x2F;format,png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '6.0.0',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://blog.lemayli.com/2020/03/07/艺术探索笔记：View-的事件体系/"/>





  <title>艺术探索笔记：View 的事件体系 | lemay</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"> <div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">lemay</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://blog.lemayli.com/2020/03/07/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%EF%BC%9AView-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="lemay">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="lemay">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">艺术探索笔记：View 的事件体系</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2020-03-07T16:00:32+08:00">2020-03-07</time>
            

            

            
          </span>

          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">25k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">23 mins.</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="View-的事件体系"><a href="#View-的事件体系" class="headerlink" title="View 的事件体系"></a>View 的事件体系</h1><p>View 是一种界面层的控件的一种抽象，它代表着一个控件。ViewGroup 继承自 View，内部包含了许多个控件，即一组 View。这意味着 View 本身可以是单个控件也可以是多个控件组成的一组控件，即 View 树的结构。<br><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9zczIuYmRzdGF0aWMuY29tLzcwY0Z2blNoX1ExWW54R2twb1dLMUhGNmhoeS9pdC91PTIwNDY3MTg3NTQsNjA4ODM4NDMyJmZtPTE1JmdwPTAuanBnJTIwJTIyVmlldyUyMEhpZXJhcmNoeSUyMg?x-oss-process=image/format,png" alt="View Hierarchy"><br>所以 View 的事件体系即控件的事件体系。</p>
<h2 id="View的基础知识"><a href="#View的基础知识" class="headerlink" title="View的基础知识"></a>View的基础知识</h2><h3 id="View的位置参数"><a href="#View的位置参数" class="headerlink" title="View的位置参数"></a>View的位置参数</h3><p>View 的位置主要由它的四个顶点来决定，分别对应于 View 的四个属性：top、left、right、bottom。这些坐标都是相对于 View 的父容器来说的，它是一种相对坐标。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">left = getLeft();</span><br><span class="line">right = getRight();</span><br><span class="line">top = getTop();</span><br><span class="line">bottom = getBottom();</span><br></pre></td></tr></table></figure>

<p>此外，View 还有几个参数：x、y、translateX、translateY，其中 x 和 y 是 View 左上角的坐标，translateX 和 translateY 是 View 左上角相对于父容器的偏移量。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = left + translateX</span><br><span class="line">y = right + translateY</span><br></pre></td></tr></table></figure>

<p>View 在平移的过程中，top 和 left 表示的是原始左上角的位置参数，其值不会发生改变，此时发生改变的是x、y、translationX和translationY这四个参数。</p>
<h3 id="MotionEvent、TouchSlop"><a href="#MotionEvent、TouchSlop" class="headerlink" title="MotionEvent、TouchSlop"></a>MotionEvent、TouchSlop</h3><h4 id="MotionEvent"><a href="#MotionEvent" class="headerlink" title="MotionEvent"></a>MotionEvent</h4><p>在手指接触屏幕后所产生的一系列事件中，典型的事件类型有如下几种：</p>
<ul>
<li><p>ACTION_DOWN——手指刚接触屏幕；</p>
</li>
<li><p>ACTION_MOVE——手指在屏幕上移动；</p>
</li>
<li><p>ACTION_UP——手机从屏幕上松开的一瞬间。   </p>
</li>
</ul>
<p>正常情况下，一次手指触摸屏幕的行为会触发一系列点击事件，考虑如下几种情况：</p>
<ul>
<li>点击屏幕后离开松开，事件序列为DOWN -&gt; UP；</li>
<li>点击屏幕滑动一会再松开，事件序列为DOWN -&gt; MOVE -&gt; … &gt; MOVE -&gt; UP。</li>
</ul>
<p>过 MotionEvent 对象我们可以得到点击事件发生的 x 和 y 坐标。</p>
<ul>
<li><p><code>getX/getY</code> 相对于当前 View 左上角的 x 和 y 坐标</p>
</li>
<li><p><code>getRawX/getRawY</code> 相对于手机屏幕左上角的 x 和 y 坐标</p>
</li>
</ul>
<h4 id="TouchSlop"><a href="#TouchSlop" class="headerlink" title="TouchSlop"></a>TouchSlop</h4><p>TouchSlop 是系统所能识别出的被认为是滑动的最小距离。这是一个常量，和设备有关，在不同设备上这个值可能是不同的，可以通过系统方法获取。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ViewConfiguration.get(context).getScaledTouchSlop();</span><br></pre></td></tr></table></figure>

<h3 id="VelocityTracker、GestureDetector、Scroller"><a href="#VelocityTracker、GestureDetector、Scroller" class="headerlink" title="VelocityTracker、GestureDetector、Scroller"></a>VelocityTracker、GestureDetector、Scroller</h3><h4 id="VelocityTracker"><a href="#VelocityTracker" class="headerlink" title="VelocityTracker"></a>VelocityTracker</h4><p>用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (tracker == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">//使用 obtain()方法得到这个类的实例</span></span><br><span class="line">	tracker = VelocityTracker.obtain();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//addMovement(MotionEvent)函数将你接受到的 motionEvent 加入到 tracker 类实例中</span></span><br><span class="line">tracker.addMovement(event);</span><br><span class="line"><span class="comment">// 计算 1s 内手指的滑动速度</span></span><br><span class="line">tracker.computeCurrentVelocity(<span class="number">1000</span>);</span><br><span class="line"><span class="keyword">int</span> xVelocity = tracker.getXVelocity();</span><br><span class="line"><span class="keyword">int</span> yVelocity = tracker.getYVelocity();</span><br><span class="line"><span class="comment">// 结束时，重置并回收内存</span></span><br><span class="line">tracker.clear();</span><br><span class="line">tracker.recycle();</span><br><span class="line">tracker = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure>

<p>在上面的例子中，我们通过 <code>computeCurrentVelocity(int)</code> 来初始化速率的单位，通过 velocity 的正负值来判断滑动的方向。</p>
<h4 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h4><p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行为。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化 GestureDetector 对象</span></span><br><span class="line">gestureDetector = <span class="keyword">new</span> GestureDetector(context, <span class="keyword">this</span>);</span><br><span class="line">gestureDetector.setIsLongpressEnabled(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">// onTouchEvent</span></span><br><span class="line"><span class="keyword">return</span> gestureDetector.onTouchEvent(event);</span><br></pre></td></tr></table></figure>

<p>常用方法：onSingleTapUp（单击）、 onFling（快速滑动）、onScroll（拖动）、onLongPress（长按）和onDoubleTap（双击）。</p>
<h4 id="Scroller"><a href="#Scroller" class="headerlink" title="Scroller"></a>Scroller</h4><p>用于实现 View 的弹性滑动。使用 View 的 scrollTo、scrollBy 方法和 View 的 computeScroll 方法配合使用实现弹性滑动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">scroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line"></span><br><span class="line">scroller.fling();</span><br><span class="line">postInvalidate();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (scroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(scroller.getCurrX(), scroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="VIew的滑动"><a href="#VIew的滑动" class="headerlink" title="VIew的滑动"></a>VIew的滑动</h2><p>View 的滑动主要可以通过三种方式来实现：</p>
<ul>
<li><p>通过 View 本身提供的 scrollTo/scrollBy 方法来实现滑动。</p>
</li>
<li><p>通过动画给 View 施加平移效果来实现滑动。</p>
</li>
<li><p>通过改变 View 的 LayoutParams 使得 View 重新布局从而实现滑动。</p>
</li>
</ul>
<h3 id="scrollTo、scrollBy"><a href="#scrollTo、scrollBy" class="headerlink" title="scrollTo、scrollBy"></a>scrollTo、scrollBy</h3><p>使用 scrollTo/scrollBy 进行滑动的本质是对 View 的 mScrollX/mScrollY 属性进行修改并重绘界面。 mScrollX 的值总是等于 View 左边缘和 View 内容左边缘在水平方向的距离，而 mScrollY 的值总是等于 View 上边缘和 View 内容上边缘在竖直方向的距离。</p>
<p>scrollTo 和 scrollBy 只能改变 View 内容的位置而不能改变 View 在布局中的位置。从左向右滑动，那么 mScrollX为负值，反之为正值；如果从上往下滑动，那么 mScrollY 为负值，反之为正值。</p>
<h3 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h3><p>Android 中动画主要分为以下几类：  </p>
<ul>
<li><p>逐帧动画</p>
</li>
<li><p>补间动画</p>
</li>
<li><p>属性动画</p>
</li>
</ul>
<h4 id="逐帧动画"><a href="#逐帧动画" class="headerlink" title="逐帧动画"></a>逐帧动画</h4><p>逐帧动画的原理就是让一系列的静态图片依次播放，利用人眼“视觉暂留”的原理，实现动画。</p>
<p>通常是采用 XML 资源进行定义的，需要在 &lt;animation-list …/&gt; 标签下使用 &lt;item …/&gt; 子元素标签定义动画的全部帧，并指定各帧的持续时间。亦可通过  AnimationDrawable  类来实现。</p>
<h4 id="补间动画"><a href="#补间动画" class="headerlink" title="补间动画"></a>补间动画</h4><p>补间动画就是指开发者指定动画的开始、动画的结束的”关键帧”，而动画变化的”中间帧”由系统计算，并补齐。补间动画有四种：</p>
<ul>
<li>淡入淡出：alpha</li>
<li>位移：translate</li>
<li>缩放：scale</li>
<li>旋转：rotate</li>
</ul>
<p>补间动画一般也是通过 xml 来实现，对于 xml 形式补间动画的定义，也是需要在 res/anim/ 文件夹下定义动画资源 。亦可通过 Animation 类来实现，或 AnimationSet 来实现组合动画。</p>
<h4 id="属性动画"><a href="#属性动画" class="headerlink" title="属性动画"></a>属性动画</h4><p>属性动画可以看作是增强版的补间动画。主要通过使用 ValueAnimator  或者  ObjectAnimator  的静态工厂方法创建动画。亦可使用资源文件来定义动画。</p>
<p>PS：自定义补间动画、 interpolator、Transformation 等内容见第七章。</p>
<h3 id="改变布局参数"><a href="#改变布局参数" class="headerlink" title="改变布局参数"></a>改变布局参数</h3><p>通过修改控件 LayoutParams 对象的属性来进行动画。</p>
<h2 id="弹性滑动"><a href="#弹性滑动" class="headerlink" title="弹性滑动"></a>弹性滑动</h2><p>上述的滑动方式直接使用都会过于生硬，所以要实现弹性滑动。所谓弹性活动，就是将一次比较大的滑动分割成若干个小的滑动，并在一定的时间内完成。常见的方式：</p>
<ul>
<li>Scroller</li>
<li>Handler#postDelayed</li>
<li>Animation</li>
</ul>
<h3 id="Scroller-1"><a href="#Scroller-1" class="headerlink" title="Scroller"></a>Scroller</h3><p>实现代码见上方示例。Scroller 中定义了 startScroll 方法进行平滑滚动，filing 方法进行惯性滑动。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    mMode = SCROLL_MODE;</span><br><span class="line">    mFinished = <span class="keyword">false</span>;</span><br><span class="line">    mDuration = duration;</span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">    mStartX = startX;</span><br><span class="line">    mStartY = startY;</span><br><span class="line">    mFinalX = startX + dx;</span><br><span class="line">    mFinalY = startY + dy;</span><br><span class="line">    mDeltaX = dx;</span><br><span class="line">    mDeltaY = dy;</span><br><span class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>startX和startY表示的是滑动的起点，dx和dy表示的是要滑动的距离，而duration表示的是滑动时间，即整个滑动过程完成所需要的时间。</p>
<p>在调用 scroller.startScroll 方法后，需要调用 invalidate 方法进行重绘。View 的 draw 方法中会调用 computeScroll 方法，computeScroll 又会去向 Scroller 获取当前的 scrollX 和 scrollY；然后通过 scrollTo 方法实现滑动；接着又调用 postInvalidate 方法来进行第二次重绘，这一次重绘的过程和第一次重绘一样，还是会导致 computeScroll 方法被调用；然后继续向 Scroller 获取当前的 scrollX 和 scrollY，并通过 scrollTo 方法滑动到新的位置，如此反复，直到整个滑动过程结束。</p>
<p>scroller.computeScrollOffset 方法用来判断动画是否已经结束，返回 true 表示滑动还未结束，false 则表示滑动已经结束。computeScrollOffset 方法通过插值器 ViscousFluidInterpolator 来根据时间流逝的百分比计算出 scrollX 和 scrollY 改变的百分比并计算出当前值。</p>
<h2 id="点击事件分发机制"><a href="#点击事件分发机制" class="headerlink" title="点击事件分发机制"></a>点击事件分发机制</h2><p>所谓点击事件的事件分发，其实就是对MotionEvent事件的分发过程，即当一个 MotionEvent 产生了以后，系统需要把这个事件传递给一个具体的 View，而这个传递的过程就是分发过程。<br>点击事件的分发过程由三个重要方法共同完成：</p>
<ul>
<li><p>dispatchTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span></span></span><br></pre></td></tr></table></figure>

<p>用来进行事件的分发。如果事件能够传递给当前 View，那么此方法一定会被调用，返回结果受当前 View 的 onTouchEvent 和下级 View 的 dispatchTouchEvent 方法的影响，表示是否消耗当前事件。</p>
</li>
<li><p>onInterceptTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>
<p>判断是否拦截某个事件，如果当前 View 拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件。</p>
</li>
<li><p>onTouchEvent</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span></span></span><br></pre></td></tr></table></figure>
<p>dispatchTouchEvent方法 中调用，用来处理点击事件，返回结果表示是否消耗当前事件，如果不消耗，则在同一个事件序列中，当前 View 无法再次接收到事件。</p>
<p>上述三个方法之间的关系可以用如下伪代码来表示：   </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">boolean</span> consume = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">if</span>(onInterceptTouchEvent(event)) &#123;</span><br><span class="line">      consume = onTouchEvent(event);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      consume = child.dispatchTouchEvent(event);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>通过上面的伪代码，我们也可以大致了解点击事件的传递规则：对于一个根 ViewGroup 来说，点击事件产生后，首先会传递给它，这时它的 dispatchTouchEvent 就会被调用，如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 true 就表示它要拦截当前事件，接着事件就会交给这个 ViewGroup 处理，即它的 onTouchEvent 方法就会被调用；如果这个 ViewGroup 的 onInterceptTouchEvent 方法返回 false 就表示它不拦截当前事件，这时当前事件就会继续传递给它的子元素，接着子元素的 dispatchTouchEvent 方法就会被调用，如此反复直到事件被最终处理。</p>
<p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity -&gt; Window -&gt; View，即事件总是先传递给 Activity, Activity 再传递给 Window，最后 Window 再传递给顶级 View。顶级 View 接收到事件后，就会按照事件分发机制去分发事件。考虑一种情况，如果一个 View 的 onTouchEvent 返回 false，那么它的父容器的 onTouchEvent 将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给 Activity 处理，即 Activity 的 onTouchEvent 方法会被调用。</p>
<p>当一个 View 需要处理事件时，如果它设置了 OnTouchListener，那么 OnTouchListener 中的 onTouch 方法会被回调。这时事件如何处理还要看 onTouch 的返回值，如果返回 false，则当前 View的 onTouchEvent 方法会被调用；如果返回 true，那么 onTouchEvent 方法将不会被调用。由此可见，给 View 设置的 OnTouchListener，其优先级比 onTouchEvent 要高。在 onTouchEvent 方法中，如果当前设置的有 OnClickListener，那么它的 onClick 方法会被调用。可以看出，平时我们常用的 OnClickListener，其优先级最低，即处于事件传递的尾端。</p>
<h4 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h4><ol>
<li>同一个事件序列是指从手指接触屏幕的那一刻起，到手指离开屏幕的那一刻结束，在这个过程中所产生的一系列事件，这个事件序列以 down 事件开始，中间含有数量不定的 move 事件，最终以 up 事件结束。</li>
<li>正常情况下，一个事件序列只能被一个 View 拦截且消耗。这一条的原因可以参考（3），因为一旦一个元素拦截了某此事件，那么同一个事件序列内的所有事件都会直接交给它处理，因此同一个事件序列中的事件不能分别由两个 View 同时处理，但是通过特殊手段可以做到，比如一个 View 将本该自己处理的事件通过 onTouchEvent 强行传递给其他 View 处理。</li>
<li>某个 View 一旦决定拦截，那么这一个事件序列都只能由它来处理（如果事件序列能够传递给它的话），并且它的 onInterceptTouchEvent 不会再被调用。这条也很好理解，就是说当一个 View 决定拦截一个事件后，那么系统会把同一个事件序列内的其他方法都直接交给它来处理，因此就不用再调用这个 View 的 onInterceptTouchEvent 去询问它是否要拦截了。</li>
<li>某个 View 一旦开始处理事件，如果它不消耗 ACTION_DOWN 事件（onTouchEvent 返回了false），那么同一事件序列中的其他事件都不会再交给它来处理，并且事件将重新交由它的父元素去处理，即父元素的 onTouchEvent 会被调用。意思就是事件一旦交给一个 View 处理，那么它就必须消耗掉，否则同一事件序列中剩下的事件就不再交给它来处理了。</li>
<li>如果 View 不消耗除 ACTION_DOWN 以外的其他事件，那么这个点击事件会消失，此时父元素的 onTouchEvent 并不会被调用，并且当前 View 可以持续收到后续的事件，最终这些消失的点击事件会传递给 Activity 处理。</li>
<li>ViewGroup 默认不拦截任何事件。Android 源码中 ViewGroup 的 onInterceptTouchEvent 方法默认返回 false。</li>
<li>View 没有 onInterceptTouchEvent 方法，一旦有点击事件传递给它，那么它的 onTouchEvent 方法就会被调用。</li>
<li>View的 onTouchEvent 默认都会消耗事件（返回 true），除非它是不可点击的（clickable 和 longClickable 同时为 false）。View 的 longClickable 属性默认都为 false, clickable 属性要分情况，比如 Button 的 clickable 属性默认为 true，而 TextView 的 clickable 属性默认为 false。</li>
<li>View 的 enable 属性不影响 onTouchEvent 的默认返回值。哪怕一个 View 是 disable 状态的，只要它的 clickable 或者 longClickable 有一个为 true，那么它的 onTouchEvent 就返回 true。</li>
<li>onClick 会发生的前提是当前 View 是可点击的，并且它收到了 down 和 up 的事件。</li>
<li>事件传递过程是由外向内的，即事件总是先传递给父元素，然后再由父元素分发给子 View，通过 requestDisallowInterceptTouchEvent 方法可以在子元素中干预父元素的事件分发过程，但是 ACTION_DOWN 事件除外。</li>
</ol>
<h2 id="View的滑动冲突"><a href="#View的滑动冲突" class="headerlink" title="View的滑动冲突"></a>View的滑动冲突</h2><p>常见的滑动冲突场景可以简单分为如下三种：</p>
<ol>
<li>外部滑动方向和内部滑动方向不一致</li>
</ol>
<p>​       针对这种场景的滑动，可以根据滑动的距离差来进行判断</p>
<ul>
<li>根据滑动路径和水平方向所形成的的夹角</li>
<li>根据水平方向和竖直方向的距离差</li>
<li>根据水平和竖直方向的速度差</li>
</ul>
<ol start="2">
<li><p>外部滑动方向和内部滑动方向一致</p>
<p> 针对这种场景，只能从业务上来进行规定。</p>
</li>
<li><p>上面两种情况的嵌套</p>
<p> 和场景 2 一样，它的滑动规则更为复杂，也只能从业务上来规定。</p>
</li>
</ol>
<h3 id="滑动冲突的解决方式"><a href="#滑动冲突的解决方式" class="headerlink" title="滑动冲突的解决方式"></a>滑动冲突的解决方式</h3><p>针对滑动冲突，这里给出两种解决滑动冲突的方式：外部拦截法和内部拦截法。</p>
<h4 id="外部拦截法"><a href="#外部拦截法" class="headerlink" title="外部拦截法"></a>外部拦截法</h4><p>所谓外部拦截法是指点击事情都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要此事件就不拦截，这样就可以解决滑动冲突的问题。外部拦截法需要重写父容器的 onInterceptTouchEvent 方法，在内部做相应的拦截即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> intercepted = <span class="keyword">false</span>;</span><br><span class="line">	<span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN: &#123;</span><br><span class="line">                <span class="comment">// 必须返回 false，外部容器一旦拦截 down 事件，后续事件都会交由外部容器处理</span></span><br><span class="line">                intercepted = <span class="keyword">false</span>;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE: &#123;</span><br><span class="line">            	<span class="keyword">if</span> (外部容器需要拦截) &#123;</span><br><span class="line">                    intercepted = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    intercepted = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP: &#123;</span><br><span class="line">                <span class="comment">// 必须返回 false，如果返回 true，子元素处理事件后无法收到 up 事件，就无法触发 onClick 事件</span></span><br><span class="line">            	intercepted = <span class="keyword">false</span>;</span><br><span class="line">            	<span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> intercepted;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="内部拦截法"><a href="#内部拦截法" class="headerlink" title="内部拦截法"></a>内部拦截法</h4><p>内部拦截法是指外部容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交由父容器进行处理，这种方法和Android中的事件分发机制不一致，需要配合 requestDisallowInterceptTouchEvent 方法才能正常工作，使用起来较外部拦截法稍显复杂，我们需要重写子元素的 dispatchTouchEvent 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 拦截 down 事件，后续所有事件都会交由子元素处理</span></span><br><span class="line">            parent.requestDisallowInterceptTouchEvent(<span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span>(外部容器需要处理此类点击事件) &#123;</span><br><span class="line">                <span class="comment">// 在需要的时候，将 move 事件交由外部容器处理</span></span><br><span class="line">                parent.requestDisallowInterceptTouchEvent(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>外部容器需要重写 onInterceptTouchEvent。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 除 down 事件外，其他事件外部容器都需要拦截。</span></span><br><span class="line">    <span class="comment">// 只有这样，当子元素调用 parent.requestDisallowInterceptTouchEvent(false) 时，外部容器才能拦截并处理所需要的事件。</span></span><br><span class="line">    <span class="keyword">return</span> event.getAction() != MotionEvent.ACTION_DOWN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对场景 2 和场景 3 这些复杂的情况，需要更复杂的拦截规则。</p>

      
    </div>
    
    
    

    

    

    
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    lemay
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="http://blog.lemayli.com/2020/03/07/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%EF%BC%9AView-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/" title="艺术探索笔记：View 的事件体系">http://blog.lemayli.com/2020/03/07/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%EF%BC%9AView-%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>
    本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/3.0/" rel="external nofollow" target="_blank">CC BY-NC-SA 3.0</a> 许可协议。转载请注明出处！
  </li>
</ul>

      </div>
    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2019/11/14/%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E7%AC%94%E8%AE%B0%EF%BC%9AIPC/" rel="next" title="艺术探索笔记：IPC">
                <i class="fa fa-chevron-left"></i> 艺术探索笔记：IPC
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">lemay</p>
              <p class="site-description motion-element" itemprop="description">lemay</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7C%20archive">
              
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#View-的事件体系"><span class="nav-number">1.</span> <span class="nav-text">View 的事件体系</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#View的基础知识"><span class="nav-number">1.1.</span> <span class="nav-text">View的基础知识</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#View的位置参数"><span class="nav-number">1.1.1.</span> <span class="nav-text">View的位置参数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#MotionEvent、TouchSlop"><span class="nav-number">1.1.2.</span> <span class="nav-text">MotionEvent、TouchSlop</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#MotionEvent"><span class="nav-number">1.1.2.1.</span> <span class="nav-text">MotionEvent</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#TouchSlop"><span class="nav-number">1.1.2.2.</span> <span class="nav-text">TouchSlop</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#VelocityTracker、GestureDetector、Scroller"><span class="nav-number">1.1.3.</span> <span class="nav-text">VelocityTracker、GestureDetector、Scroller</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#VelocityTracker"><span class="nav-number">1.1.3.1.</span> <span class="nav-text">VelocityTracker</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#GestureDetector"><span class="nav-number">1.1.3.2.</span> <span class="nav-text">GestureDetector</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Scroller"><span class="nav-number">1.1.3.3.</span> <span class="nav-text">Scroller</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#VIew的滑动"><span class="nav-number">1.2.</span> <span class="nav-text">VIew的滑动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#scrollTo、scrollBy"><span class="nav-number">1.2.1.</span> <span class="nav-text">scrollTo、scrollBy</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Animation"><span class="nav-number">1.2.2.</span> <span class="nav-text">Animation</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#逐帧动画"><span class="nav-number">1.2.2.1.</span> <span class="nav-text">逐帧动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#补间动画"><span class="nav-number">1.2.2.2.</span> <span class="nav-text">补间动画</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#属性动画"><span class="nav-number">1.2.2.3.</span> <span class="nav-text">属性动画</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#改变布局参数"><span class="nav-number">1.2.3.</span> <span class="nav-text">改变布局参数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#弹性滑动"><span class="nav-number">1.3.</span> <span class="nav-text">弹性滑动</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Scroller-1"><span class="nav-number">1.3.1.</span> <span class="nav-text">Scroller</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#点击事件分发机制"><span class="nav-number">1.4.</span> <span class="nav-text">点击事件分发机制</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#结论"><span class="nav-number">1.4.0.1.</span> <span class="nav-text">结论</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#View的滑动冲突"><span class="nav-number">1.5.</span> <span class="nav-text">View的滑动冲突</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#滑动冲突的解决方式"><span class="nav-number">1.5.1.</span> <span class="nav-text">滑动冲突的解决方式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#外部拦截法"><span class="nav-number">1.5.1.1.</span> <span class="nav-text">外部拦截法</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#内部拦截法"><span class="nav-number">1.5.1.2.</span> <span class="nav-text">内部拦截法</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2019 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">lemay</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
    <span title="站点总字数">13k</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
    <span title="站点总阅读次数">12 mins.</span>
  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>






<div>
<script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<span id="busuanzi_container_site_pv" style='display:none'>
    本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
    <span class="post-meta-divider">|</span>
</span>
<span id="busuanzi_container_site_uv" style='display:none'>
    有<span id="busuanzi_value_site_uv"></span>人看过我的博客啦
</span>
</div>



        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>
























  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=6.0.0"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=6.0.0"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=6.0.0"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=6.0.0"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=6.0.0"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
